// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: engine.proto
#ifndef GRPC_engine_2eproto__INCLUDED
#define GRPC_engine_2eproto__INCLUDED

#include "engine.pb.h"

#include <functional>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/server_context.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace enginePackage {

class MainServerEngine final {
  public:
    static constexpr char const *service_full_name() { return "enginePackage.MainServerEngine"; }
    class StubInterface {
      public:
        virtual ~StubInterface() {}
        virtual ::grpc::Status placeCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                         ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncplaceCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                       ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncplaceCardRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncplaceCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                              ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncplaceCardRaw(context, request, cq));
        }
        virtual ::grpc::Status playAction(::grpc::ClientContext *context,
                                          const ::enginePackage::playActionArgs &request,
                                          ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncplayAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                        ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncplayActionRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncplayAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                               ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncplayActionRaw(context, request, cq));
        }
        virtual ::grpc::Status endTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                       ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncendTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                     ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncendTurnRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncendTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncendTurnRaw(context, request, cq));
        }
        virtual ::grpc::Status initClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                                          ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncinitClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                        ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncinitClientRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncinitClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                               ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncinitClientRaw(context, request, cq));
        }
        virtual ::grpc::Status GetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                                       ::enginePackage::FileResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::FileResponse>>
        AsyncGetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                     ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::FileResponse>>(
                AsyncGetFileRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::FileResponse>>
        PrepareAsyncGetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::FileResponse>>(
                PrepareAsyncGetFileRaw(context, request, cq));
        }
        class async_interface {
          public:
            virtual ~async_interface() {}
            virtual void placeCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                                   ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void placeCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                                   ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
            virtual void playAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                                    ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void playAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                                    ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
            virtual void endTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                                 ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void endTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                                 ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
            virtual void initClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo *request,
                                    ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void initClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo *request,
                                    ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
            virtual void GetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest *request,
                                 ::enginePackage::FileResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void GetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest *request,
                                 ::enginePackage::FileResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
        };
        typedef class async_interface experimental_async_interface;
        virtual class async_interface *async() { return nullptr; }
        class async_interface *experimental_async() {
            return async();
        }

      private:
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncplaceCardRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                          ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncplaceCardRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                 ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncplayActionRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                           ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncplayActionRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                  ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncendTurnRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                        ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncendTurnRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                               ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncinitClientRaw(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                           ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncinitClientRaw(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                                  ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::FileResponse> *
        AsyncGetFileRaw(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                        ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::FileResponse> *
        PrepareAsyncGetFileRaw(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                               ::grpc::CompletionQueue *cq) = 0;
    };
    class Stub final : public StubInterface {
      public:
        Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
             const ::grpc::StubOptions &options = ::grpc::StubOptions());
        ::grpc::Status placeCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                 ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncplaceCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                       ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncplaceCardRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncplaceCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                              ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncplaceCardRaw(context, request, cq));
        }
        ::grpc::Status playAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                  ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncplayAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                        ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncplayActionRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncplayAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                               ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncplayActionRaw(context, request, cq));
        }
        ::grpc::Status endTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                               ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncendTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                     ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncendTurnRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncendTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncendTurnRaw(context, request, cq));
        }
        ::grpc::Status initClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                                  ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncinitClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                        ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncinitClientRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncinitClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                               ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncinitClientRaw(context, request, cq));
        }
        ::grpc::Status GetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                               ::enginePackage::FileResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::FileResponse>>
        AsyncGetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                     ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::FileResponse>>(
                AsyncGetFileRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::FileResponse>>
        PrepareAsyncGetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::FileResponse>>(
                PrepareAsyncGetFileRaw(context, request, cq));
        }
        class async final : public StubInterface::async_interface {
          public:
            void placeCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                           ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) override;
            void placeCard(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                           ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
            void playAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                            ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) override;
            void playAction(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                            ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
            void endTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                         ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) override;
            void endTurn(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                         ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
            void initClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo *request,
                            ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) override;
            void initClient(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo *request,
                            ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
            void GetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest *request,
                         ::enginePackage::FileResponse *response, std::function<void(::grpc::Status)>) override;
            void GetFile(::grpc::ClientContext *context, const ::enginePackage::FileRequest *request,
                         ::enginePackage::FileResponse *response, ::grpc::ClientUnaryReactor *reactor) override;

          private:
            friend class Stub;
            explicit async(Stub *stub) : stub_(stub) {}
            Stub *stub() { return stub_; }
            Stub *stub_;
        };
        class async *async() override {
            return &async_stub_;
        }

      private:
        std::shared_ptr<::grpc::ChannelInterface> channel_;
        class async async_stub_ {
            this
        };
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncplaceCardRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                          ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncplaceCardRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                 ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncplayActionRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                           ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncplayActionRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                  ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncendTurnRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                        ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncendTurnRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                               ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncinitClientRaw(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                           ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncinitClientRaw(::grpc::ClientContext *context, const ::enginePackage::ClientNetInfo &request,
                                  ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::FileResponse> *
        AsyncGetFileRaw(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                        ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::FileResponse> *
        PrepareAsyncGetFileRaw(::grpc::ClientContext *context, const ::enginePackage::FileRequest &request,
                               ::grpc::CompletionQueue *cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_placeCard_;
        const ::grpc::internal::RpcMethod rpcmethod_playAction_;
        const ::grpc::internal::RpcMethod rpcmethod_endTurn_;
        const ::grpc::internal::RpcMethod rpcmethod_initClient_;
        const ::grpc::internal::RpcMethod rpcmethod_GetFile_;
    };
    static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                                         const ::grpc::StubOptions &options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
      public:
        Service();
        virtual ~Service();
        virtual ::grpc::Status placeCard(::grpc::ServerContext *context, const ::enginePackage::placeCardArgs *request,
                                         ::enginePackage::ServerResponse *response);
        virtual ::grpc::Status playAction(::grpc::ServerContext *context,
                                          const ::enginePackage::playActionArgs *request,
                                          ::enginePackage::ServerResponse *response);
        virtual ::grpc::Status endTurn(::grpc::ServerContext *context, const ::enginePackage::endTurnArgs *request,
                                       ::enginePackage::ServerResponse *response);
        virtual ::grpc::Status initClient(::grpc::ServerContext *context, const ::enginePackage::ClientNetInfo *request,
                                          ::enginePackage::ServerResponse *response);
        virtual ::grpc::Status GetFile(::grpc::ServerContext *context, const ::enginePackage::FileRequest *request,
                                       ::enginePackage::FileResponse *response);
    };
    template <class BaseClass> class WithAsyncMethod_placeCard : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_placeCard() { ::grpc::Service::MarkMethodAsync(0); }
        ~WithAsyncMethod_placeCard() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCard(::grpc::ServerContext * /*context*/,
                                 const ::enginePackage::placeCardArgs * /*request*/,
                                 ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplaceCard(::grpc::ServerContext *context, ::enginePackage::placeCardArgs *request,
                              ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                              ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                              void *tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_playAction : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_playAction() { ::grpc::Service::MarkMethodAsync(1); }
        ~WithAsyncMethod_playAction() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playAction(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::playActionArgs * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplayAction(::grpc::ServerContext *context, ::enginePackage::playActionArgs *request,
                               ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                               ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                               void *tag) {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_endTurn : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_endTurn() { ::grpc::Service::MarkMethodAsync(2); }
        ~WithAsyncMethod_endTurn() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurn(::grpc::ServerContext * /*context*/, const ::enginePackage::endTurnArgs * /*request*/,
                               ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestendTurn(::grpc::ServerContext *context, ::enginePackage::endTurnArgs *request,
                            ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                            ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                            void *tag) {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_initClient : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_initClient() { ::grpc::Service::MarkMethodAsync(3); }
        ~WithAsyncMethod_initClient() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status initClient(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::ClientNetInfo * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestinitClient(::grpc::ServerContext *context, ::enginePackage::ClientNetInfo *request,
                               ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                               ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                               void *tag) {
            ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_GetFile : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_GetFile() { ::grpc::Service::MarkMethodAsync(4); }
        ~WithAsyncMethod_GetFile() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status GetFile(::grpc::ServerContext * /*context*/, const ::enginePackage::FileRequest * /*request*/,
                               ::enginePackage::FileResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetFile(::grpc::ServerContext *context, ::enginePackage::FileRequest *request,
                            ::grpc::ServerAsyncResponseWriter<::enginePackage::FileResponse> *response,
                            ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                            void *tag) {
            ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_placeCard<WithAsyncMethod_playAction<
        WithAsyncMethod_endTurn<WithAsyncMethod_initClient<WithAsyncMethod_GetFile<Service>>>>>
        AsyncService;
    template <class BaseClass> class WithCallbackMethod_placeCard : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_placeCard() {
            ::grpc::Service::MarkMethodCallback(
                0, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::placeCardArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::placeCardArgs *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->placeCard(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_placeCard(
            ::grpc::MessageAllocator<::enginePackage::placeCardArgs, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(0);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::placeCardArgs,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_placeCard() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCard(::grpc::ServerContext * /*context*/,
                                 const ::enginePackage::placeCardArgs * /*request*/,
                                 ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *placeCard(::grpc::CallbackServerContext * /*context*/,
                                                      const ::enginePackage::placeCardArgs * /*request*/,
                                                      ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_playAction : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_playAction() {
            ::grpc::Service::MarkMethodCallback(
                1, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::playActionArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::playActionArgs *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->playAction(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_playAction(
            ::grpc::MessageAllocator<::enginePackage::playActionArgs, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(1);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::playActionArgs,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_playAction() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playAction(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::playActionArgs * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *playAction(::grpc::CallbackServerContext * /*context*/,
                                                       const ::enginePackage::playActionArgs * /*request*/,
                                                       ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_endTurn : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_endTurn() {
            ::grpc::Service::MarkMethodCallback(
                2, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::endTurnArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::endTurnArgs *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->endTurn(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_endTurn(
            ::grpc::MessageAllocator<::enginePackage::endTurnArgs, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(2);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::endTurnArgs,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_endTurn() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurn(::grpc::ServerContext * /*context*/, const ::enginePackage::endTurnArgs * /*request*/,
                               ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *endTurn(::grpc::CallbackServerContext * /*context*/,
                                                    const ::enginePackage::endTurnArgs * /*request*/,
                                                    ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_initClient : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_initClient() {
            ::grpc::Service::MarkMethodCallback(
                3, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::ClientNetInfo,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::ClientNetInfo *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->initClient(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_initClient(
            ::grpc::MessageAllocator<::enginePackage::ClientNetInfo, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(3);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::ClientNetInfo,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_initClient() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status initClient(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::ClientNetInfo * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *initClient(::grpc::CallbackServerContext * /*context*/,
                                                       const ::enginePackage::ClientNetInfo * /*request*/,
                                                       ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_GetFile : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_GetFile() {
            ::grpc::Service::MarkMethodCallback(
                4,
                new ::grpc::internal::CallbackUnaryHandler<::enginePackage::FileRequest, ::enginePackage::FileResponse>(
                    [this](::grpc::CallbackServerContext *context, const ::enginePackage::FileRequest *request,
                           ::enginePackage::FileResponse *response) {
                        return this->GetFile(context, request, response);
                    }));
        }
        void SetMessageAllocatorFor_GetFile(
            ::grpc::MessageAllocator<::enginePackage::FileRequest, ::enginePackage::FileResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(4);
            static_cast<
                ::grpc::internal::CallbackUnaryHandler<::enginePackage::FileRequest, ::enginePackage::FileResponse> *>(
                handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_GetFile() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status GetFile(::grpc::ServerContext * /*context*/, const ::enginePackage::FileRequest * /*request*/,
                               ::enginePackage::FileResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *GetFile(::grpc::CallbackServerContext * /*context*/,
                                                    const ::enginePackage::FileRequest * /*request*/,
                                                    ::enginePackage::FileResponse * /*response*/) {
            return nullptr;
        }
    };
    typedef WithCallbackMethod_placeCard<WithCallbackMethod_playAction<
        WithCallbackMethod_endTurn<WithCallbackMethod_initClient<WithCallbackMethod_GetFile<Service>>>>>
        CallbackService;
    typedef CallbackService ExperimentalCallbackService;
    template <class BaseClass> class WithGenericMethod_placeCard : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_placeCard() { ::grpc::Service::MarkMethodGeneric(0); }
        ~WithGenericMethod_placeCard() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCard(::grpc::ServerContext * /*context*/,
                                 const ::enginePackage::placeCardArgs * /*request*/,
                                 ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_playAction : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_playAction() { ::grpc::Service::MarkMethodGeneric(1); }
        ~WithGenericMethod_playAction() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playAction(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::playActionArgs * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_endTurn : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_endTurn() { ::grpc::Service::MarkMethodGeneric(2); }
        ~WithGenericMethod_endTurn() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurn(::grpc::ServerContext * /*context*/, const ::enginePackage::endTurnArgs * /*request*/,
                               ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_initClient : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_initClient() { ::grpc::Service::MarkMethodGeneric(3); }
        ~WithGenericMethod_initClient() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status initClient(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::ClientNetInfo * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_GetFile : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_GetFile() { ::grpc::Service::MarkMethodGeneric(4); }
        ~WithGenericMethod_GetFile() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status GetFile(::grpc::ServerContext * /*context*/, const ::enginePackage::FileRequest * /*request*/,
                               ::enginePackage::FileResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithRawMethod_placeCard : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_placeCard() { ::grpc::Service::MarkMethodRaw(0); }
        ~WithRawMethod_placeCard() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCard(::grpc::ServerContext * /*context*/,
                                 const ::enginePackage::placeCardArgs * /*request*/,
                                 ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplaceCard(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                              ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                              ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                              void *tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_playAction : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_playAction() { ::grpc::Service::MarkMethodRaw(1); }
        ~WithRawMethod_playAction() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playAction(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::playActionArgs * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplayAction(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                               ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                               ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                               void *tag) {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_endTurn : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_endTurn() { ::grpc::Service::MarkMethodRaw(2); }
        ~WithRawMethod_endTurn() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurn(::grpc::ServerContext * /*context*/, const ::enginePackage::endTurnArgs * /*request*/,
                               ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestendTurn(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                            ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                            void *tag) {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_initClient : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_initClient() { ::grpc::Service::MarkMethodRaw(3); }
        ~WithRawMethod_initClient() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status initClient(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::ClientNetInfo * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestinitClient(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                               ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                               ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                               void *tag) {
            ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_GetFile : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_GetFile() { ::grpc::Service::MarkMethodRaw(4); }
        ~WithRawMethod_GetFile() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status GetFile(::grpc::ServerContext * /*context*/, const ::enginePackage::FileRequest * /*request*/,
                               ::enginePackage::FileResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetFile(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                            ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                            void *tag) {
            ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_placeCard : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_placeCard() {
            ::grpc::Service::MarkMethodRawCallback(
                0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                       [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                              ::grpc::ByteBuffer *response) { return this->placeCard(context, request, response); }));
        }
        ~WithRawCallbackMethod_placeCard() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCard(::grpc::ServerContext * /*context*/,
                                 const ::enginePackage::placeCardArgs * /*request*/,
                                 ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *placeCard(::grpc::CallbackServerContext * /*context*/,
                                                      const ::grpc::ByteBuffer * /*request*/,
                                                      ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_playAction : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_playAction() {
            ::grpc::Service::MarkMethodRawCallback(
                1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                       [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                              ::grpc::ByteBuffer *response) { return this->playAction(context, request, response); }));
        }
        ~WithRawCallbackMethod_playAction() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playAction(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::playActionArgs * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *playAction(::grpc::CallbackServerContext * /*context*/,
                                                       const ::grpc::ByteBuffer * /*request*/,
                                                       ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_endTurn : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_endTurn() {
            ::grpc::Service::MarkMethodRawCallback(
                2, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                       [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                              ::grpc::ByteBuffer *response) { return this->endTurn(context, request, response); }));
        }
        ~WithRawCallbackMethod_endTurn() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurn(::grpc::ServerContext * /*context*/, const ::enginePackage::endTurnArgs * /*request*/,
                               ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *endTurn(::grpc::CallbackServerContext * /*context*/,
                                                    const ::grpc::ByteBuffer * /*request*/,
                                                    ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_initClient : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_initClient() {
            ::grpc::Service::MarkMethodRawCallback(
                3, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                       [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                              ::grpc::ByteBuffer *response) { return this->initClient(context, request, response); }));
        }
        ~WithRawCallbackMethod_initClient() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status initClient(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::ClientNetInfo * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *initClient(::grpc::CallbackServerContext * /*context*/,
                                                       const ::grpc::ByteBuffer * /*request*/,
                                                       ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_GetFile : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_GetFile() {
            ::grpc::Service::MarkMethodRawCallback(
                4, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                       [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                              ::grpc::ByteBuffer *response) { return this->GetFile(context, request, response); }));
        }
        ~WithRawCallbackMethod_GetFile() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status GetFile(::grpc::ServerContext * /*context*/, const ::enginePackage::FileRequest * /*request*/,
                               ::enginePackage::FileResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *GetFile(::grpc::CallbackServerContext * /*context*/,
                                                    const ::grpc::ByteBuffer * /*request*/,
                                                    ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithStreamedUnaryMethod_placeCard : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_placeCard() {
            ::grpc::Service::MarkMethodStreamed(
                0,
                new ::grpc::internal::StreamedUnaryHandler<::enginePackage::placeCardArgs,
                                                           ::enginePackage::ServerResponse>(
                    [this](::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::placeCardArgs, ::enginePackage::ServerResponse>
                               *streamer) { return this->StreamedplaceCard(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_placeCard() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status placeCard(::grpc::ServerContext * /*context*/,
                                 const ::enginePackage::placeCardArgs * /*request*/,
                                 ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedplaceCard(::grpc::ServerContext *context,
                          ::grpc::ServerUnaryStreamer<::enginePackage::placeCardArgs, ::enginePackage::ServerResponse>
                              *server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_playAction : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_playAction() {
            ::grpc::Service::MarkMethodStreamed(
                1,
                new ::grpc::internal::StreamedUnaryHandler<::enginePackage::playActionArgs,
                                                           ::enginePackage::ServerResponse>(
                    [this](::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::playActionArgs, ::enginePackage::ServerResponse>
                               *streamer) { return this->StreamedplayAction(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_playAction() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status playAction(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::playActionArgs * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedplayAction(::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::playActionArgs, ::enginePackage::ServerResponse>
                               *server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_endTurn : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_endTurn() {
            ::grpc::Service::MarkMethodStreamed(
                2, new ::grpc::internal::StreamedUnaryHandler<::enginePackage::endTurnArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::ServerContext *context,
                              ::grpc::ServerUnaryStreamer<::enginePackage::endTurnArgs, ::enginePackage::ServerResponse>
                                  *streamer) { return this->StreamedendTurn(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_endTurn() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status endTurn(::grpc::ServerContext * /*context*/, const ::enginePackage::endTurnArgs * /*request*/,
                               ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedendTurn(::grpc::ServerContext *context,
                        ::grpc::ServerUnaryStreamer<::enginePackage::endTurnArgs, ::enginePackage::ServerResponse>
                            *server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_initClient : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_initClient() {
            ::grpc::Service::MarkMethodStreamed(
                3,
                new ::grpc::internal::StreamedUnaryHandler<::enginePackage::ClientNetInfo,
                                                           ::enginePackage::ServerResponse>(
                    [this](::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::ClientNetInfo, ::enginePackage::ServerResponse>
                               *streamer) { return this->StreamedinitClient(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_initClient() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status initClient(::grpc::ServerContext * /*context*/,
                                  const ::enginePackage::ClientNetInfo * /*request*/,
                                  ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedinitClient(::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::ClientNetInfo, ::enginePackage::ServerResponse>
                               *server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_GetFile : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_GetFile() {
            ::grpc::Service::MarkMethodStreamed(
                4,
                new ::grpc::internal::StreamedUnaryHandler<::enginePackage::FileRequest, ::enginePackage::FileResponse>(
                    [this](::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::FileRequest, ::enginePackage::FileResponse>
                               *streamer) { return this->StreamedGetFile(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_GetFile() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status GetFile(::grpc::ServerContext * /*context*/, const ::enginePackage::FileRequest * /*request*/,
                               ::enginePackage::FileResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedGetFile(::grpc::ServerContext *context,
                        ::grpc::ServerUnaryStreamer<::enginePackage::FileRequest, ::enginePackage::FileResponse>
                            *server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_placeCard<WithStreamedUnaryMethod_playAction<
        WithStreamedUnaryMethod_endTurn<WithStreamedUnaryMethod_initClient<WithStreamedUnaryMethod_GetFile<Service>>>>>
        StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_placeCard<WithStreamedUnaryMethod_playAction<
        WithStreamedUnaryMethod_endTurn<WithStreamedUnaryMethod_initClient<WithStreamedUnaryMethod_GetFile<Service>>>>>
        StreamedService;
};

class SlaveServerEngine final {
  public:
    static constexpr char const *service_full_name() { return "enginePackage.SlaveServerEngine"; }
    class StubInterface {
      public:
        virtual ~StubInterface() {}
        virtual ::grpc::Status placeCardSlave(::grpc::ClientContext *context,
                                              const ::enginePackage::placeCardArgs &request,
                                              ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncplaceCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncplaceCardSlaveRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncplaceCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                   ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncplaceCardSlaveRaw(context, request, cq));
        }
        virtual ::grpc::Status playActionSlave(::grpc::ClientContext *context,
                                               const ::enginePackage::playActionArgs &request,
                                               ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncplayActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                             ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncplayActionSlaveRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncplayActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                    ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncplayActionSlaveRaw(context, request, cq));
        }
        virtual ::grpc::Status endTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                            ::enginePackage::ServerResponse *response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        AsyncendTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                          ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                AsyncendTurnSlaveRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>
        PrepareAsyncendTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                 ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse>>(
                PrepareAsyncendTurnSlaveRaw(context, request, cq));
        }
        class async_interface {
          public:
            virtual ~async_interface() {}
            virtual void placeCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                                        ::enginePackage::ServerResponse *response,
                                        std::function<void(::grpc::Status)>) = 0;
            virtual void placeCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                                        ::enginePackage::ServerResponse *response,
                                        ::grpc::ClientUnaryReactor *reactor) = 0;
            virtual void playActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                                         ::enginePackage::ServerResponse *response,
                                         std::function<void(::grpc::Status)>) = 0;
            virtual void playActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                                         ::enginePackage::ServerResponse *response,
                                         ::grpc::ClientUnaryReactor *reactor) = 0;
            virtual void endTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                                      ::enginePackage::ServerResponse *response,
                                      std::function<void(::grpc::Status)>) = 0;
            virtual void endTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                                      ::enginePackage::ServerResponse *response,
                                      ::grpc::ClientUnaryReactor *reactor) = 0;
        };
        typedef class async_interface experimental_async_interface;
        virtual class async_interface *async() { return nullptr; }
        class async_interface *experimental_async() {
            return async();
        }

      private:
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncplaceCardSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                               ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncplaceCardSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                      ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncplayActionSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncplayActionSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                       ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        AsyncendTurnSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                             ::grpc::CompletionQueue *cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::enginePackage::ServerResponse> *
        PrepareAsyncendTurnSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                    ::grpc::CompletionQueue *cq) = 0;
    };
    class Stub final : public StubInterface {
      public:
        Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
             const ::grpc::StubOptions &options = ::grpc::StubOptions());
        ::grpc::Status placeCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                      ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncplaceCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncplaceCardSlaveRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncplaceCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                   ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncplaceCardSlaveRaw(context, request, cq));
        }
        ::grpc::Status playActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                       ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncplayActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                             ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncplayActionSlaveRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncplayActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                    ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncplayActionSlaveRaw(context, request, cq));
        }
        ::grpc::Status endTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                    ::enginePackage::ServerResponse *response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        AsyncendTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                          ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                AsyncendTurnSlaveRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>
        PrepareAsyncendTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                 ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse>>(
                PrepareAsyncendTurnSlaveRaw(context, request, cq));
        }
        class async final : public StubInterface::async_interface {
          public:
            void placeCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                                ::enginePackage::ServerResponse *response,
                                std::function<void(::grpc::Status)>) override;
            void placeCardSlave(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs *request,
                                ::enginePackage::ServerResponse *response,
                                ::grpc::ClientUnaryReactor *reactor) override;
            void playActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                                 ::enginePackage::ServerResponse *response,
                                 std::function<void(::grpc::Status)>) override;
            void playActionSlave(::grpc::ClientContext *context, const ::enginePackage::playActionArgs *request,
                                 ::enginePackage::ServerResponse *response,
                                 ::grpc::ClientUnaryReactor *reactor) override;
            void endTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                              ::enginePackage::ServerResponse *response, std::function<void(::grpc::Status)>) override;
            void endTurnSlave(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs *request,
                              ::enginePackage::ServerResponse *response, ::grpc::ClientUnaryReactor *reactor) override;

          private:
            friend class Stub;
            explicit async(Stub *stub) : stub_(stub) {}
            Stub *stub() { return stub_; }
            Stub *stub_;
        };
        class async *async() override {
            return &async_stub_;
        }

      private:
        std::shared_ptr<::grpc::ChannelInterface> channel_;
        class async async_stub_ {
            this
        };
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncplaceCardSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                               ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncplaceCardSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::placeCardArgs &request,
                                      ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncplayActionSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncplayActionSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::playActionArgs &request,
                                       ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        AsyncendTurnSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                             ::grpc::CompletionQueue *cq) override;
        ::grpc::ClientAsyncResponseReader<::enginePackage::ServerResponse> *
        PrepareAsyncendTurnSlaveRaw(::grpc::ClientContext *context, const ::enginePackage::endTurnArgs &request,
                                    ::grpc::CompletionQueue *cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_placeCardSlave_;
        const ::grpc::internal::RpcMethod rpcmethod_playActionSlave_;
        const ::grpc::internal::RpcMethod rpcmethod_endTurnSlave_;
    };
    static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                                         const ::grpc::StubOptions &options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
      public:
        Service();
        virtual ~Service();
        virtual ::grpc::Status placeCardSlave(::grpc::ServerContext *context,
                                              const ::enginePackage::placeCardArgs *request,
                                              ::enginePackage::ServerResponse *response);
        virtual ::grpc::Status playActionSlave(::grpc::ServerContext *context,
                                               const ::enginePackage::playActionArgs *request,
                                               ::enginePackage::ServerResponse *response);
        virtual ::grpc::Status endTurnSlave(::grpc::ServerContext *context, const ::enginePackage::endTurnArgs *request,
                                            ::enginePackage::ServerResponse *response);
    };
    template <class BaseClass> class WithAsyncMethod_placeCardSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_placeCardSlave() { ::grpc::Service::MarkMethodAsync(0); }
        ~WithAsyncMethod_placeCardSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCardSlave(::grpc::ServerContext * /*context*/,
                                      const ::enginePackage::placeCardArgs * /*request*/,
                                      ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplaceCardSlave(::grpc::ServerContext *context, ::enginePackage::placeCardArgs *request,
                                   ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                                   ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                                   void *tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_playActionSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_playActionSlave() { ::grpc::Service::MarkMethodAsync(1); }
        ~WithAsyncMethod_playActionSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playActionSlave(::grpc::ServerContext * /*context*/,
                                       const ::enginePackage::playActionArgs * /*request*/,
                                       ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplayActionSlave(::grpc::ServerContext *context, ::enginePackage::playActionArgs *request,
                                    ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                                    ::grpc::CompletionQueue *new_call_cq,
                                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_endTurnSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithAsyncMethod_endTurnSlave() { ::grpc::Service::MarkMethodAsync(2); }
        ~WithAsyncMethod_endTurnSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurnSlave(::grpc::ServerContext * /*context*/,
                                    const ::enginePackage::endTurnArgs * /*request*/,
                                    ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestendTurnSlave(::grpc::ServerContext *context, ::enginePackage::endTurnArgs *request,
                                 ::grpc::ServerAsyncResponseWriter<::enginePackage::ServerResponse> *response,
                                 ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                                 void *tag) {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_placeCardSlave<WithAsyncMethod_playActionSlave<WithAsyncMethod_endTurnSlave<Service>>>
        AsyncService;
    template <class BaseClass> class WithCallbackMethod_placeCardSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_placeCardSlave() {
            ::grpc::Service::MarkMethodCallback(
                0, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::placeCardArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::placeCardArgs *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->placeCardSlave(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_placeCardSlave(
            ::grpc::MessageAllocator<::enginePackage::placeCardArgs, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(0);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::placeCardArgs,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_placeCardSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCardSlave(::grpc::ServerContext * /*context*/,
                                      const ::enginePackage::placeCardArgs * /*request*/,
                                      ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *placeCardSlave(::grpc::CallbackServerContext * /*context*/,
                                                           const ::enginePackage::placeCardArgs * /*request*/,
                                                           ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_playActionSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_playActionSlave() {
            ::grpc::Service::MarkMethodCallback(
                1, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::playActionArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::playActionArgs *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->playActionSlave(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_playActionSlave(
            ::grpc::MessageAllocator<::enginePackage::playActionArgs, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(1);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::playActionArgs,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_playActionSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playActionSlave(::grpc::ServerContext * /*context*/,
                                       const ::enginePackage::playActionArgs * /*request*/,
                                       ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *playActionSlave(::grpc::CallbackServerContext * /*context*/,
                                                            const ::enginePackage::playActionArgs * /*request*/,
                                                            ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_endTurnSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithCallbackMethod_endTurnSlave() {
            ::grpc::Service::MarkMethodCallback(
                2, new ::grpc::internal::CallbackUnaryHandler<::enginePackage::endTurnArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::CallbackServerContext *context, const ::enginePackage::endTurnArgs *request,
                              ::enginePackage::ServerResponse *response) {
                           return this->endTurnSlave(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_endTurnSlave(
            ::grpc::MessageAllocator<::enginePackage::endTurnArgs, ::enginePackage::ServerResponse> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(2);
            static_cast<::grpc::internal::CallbackUnaryHandler<::enginePackage::endTurnArgs,
                                                               ::enginePackage::ServerResponse> *>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_endTurnSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurnSlave(::grpc::ServerContext * /*context*/,
                                    const ::enginePackage::endTurnArgs * /*request*/,
                                    ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *endTurnSlave(::grpc::CallbackServerContext * /*context*/,
                                                         const ::enginePackage::endTurnArgs * /*request*/,
                                                         ::enginePackage::ServerResponse * /*response*/) {
            return nullptr;
        }
    };
    typedef WithCallbackMethod_placeCardSlave<
        WithCallbackMethod_playActionSlave<WithCallbackMethod_endTurnSlave<Service>>>
        CallbackService;
    typedef CallbackService ExperimentalCallbackService;
    template <class BaseClass> class WithGenericMethod_placeCardSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_placeCardSlave() { ::grpc::Service::MarkMethodGeneric(0); }
        ~WithGenericMethod_placeCardSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCardSlave(::grpc::ServerContext * /*context*/,
                                      const ::enginePackage::placeCardArgs * /*request*/,
                                      ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_playActionSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_playActionSlave() { ::grpc::Service::MarkMethodGeneric(1); }
        ~WithGenericMethod_playActionSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playActionSlave(::grpc::ServerContext * /*context*/,
                                       const ::enginePackage::playActionArgs * /*request*/,
                                       ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_endTurnSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithGenericMethod_endTurnSlave() { ::grpc::Service::MarkMethodGeneric(2); }
        ~WithGenericMethod_endTurnSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurnSlave(::grpc::ServerContext * /*context*/,
                                    const ::enginePackage::endTurnArgs * /*request*/,
                                    ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithRawMethod_placeCardSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_placeCardSlave() { ::grpc::Service::MarkMethodRaw(0); }
        ~WithRawMethod_placeCardSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCardSlave(::grpc::ServerContext * /*context*/,
                                      const ::enginePackage::placeCardArgs * /*request*/,
                                      ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplaceCardSlave(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                   ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                   ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                                   void *tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_playActionSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_playActionSlave() { ::grpc::Service::MarkMethodRaw(1); }
        ~WithRawMethod_playActionSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playActionSlave(::grpc::ServerContext * /*context*/,
                                       const ::enginePackage::playActionArgs * /*request*/,
                                       ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestplayActionSlave(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                    ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                    ::grpc::CompletionQueue *new_call_cq,
                                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_endTurnSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawMethod_endTurnSlave() { ::grpc::Service::MarkMethodRaw(2); }
        ~WithRawMethod_endTurnSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurnSlave(::grpc::ServerContext * /*context*/,
                                    const ::enginePackage::endTurnArgs * /*request*/,
                                    ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestendTurnSlave(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                 ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                 ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                                 void *tag) {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_placeCardSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_placeCardSlave() {
            ::grpc::Service::MarkMethodRawCallback(
                0,
                new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                           ::grpc::ByteBuffer *response) { return this->placeCardSlave(context, request, response); }));
        }
        ~WithRawCallbackMethod_placeCardSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status placeCardSlave(::grpc::ServerContext * /*context*/,
                                      const ::enginePackage::placeCardArgs * /*request*/,
                                      ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *placeCardSlave(::grpc::CallbackServerContext * /*context*/,
                                                           const ::grpc::ByteBuffer * /*request*/,
                                                           ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_playActionSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_playActionSlave() {
            ::grpc::Service::MarkMethodRawCallback(
                1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                       [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                              ::grpc::ByteBuffer *response) {
                           return this->playActionSlave(context, request, response);
                       }));
        }
        ~WithRawCallbackMethod_playActionSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status playActionSlave(::grpc::ServerContext * /*context*/,
                                       const ::enginePackage::playActionArgs * /*request*/,
                                       ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *playActionSlave(::grpc::CallbackServerContext * /*context*/,
                                                            const ::grpc::ByteBuffer * /*request*/,
                                                            ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_endTurnSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithRawCallbackMethod_endTurnSlave() {
            ::grpc::Service::MarkMethodRawCallback(
                2,
                new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](::grpc::CallbackServerContext *context, const ::grpc::ByteBuffer *request,
                           ::grpc::ByteBuffer *response) { return this->endTurnSlave(context, request, response); }));
        }
        ~WithRawCallbackMethod_endTurnSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status endTurnSlave(::grpc::ServerContext * /*context*/,
                                    const ::enginePackage::endTurnArgs * /*request*/,
                                    ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor *endTurnSlave(::grpc::CallbackServerContext * /*context*/,
                                                         const ::grpc::ByteBuffer * /*request*/,
                                                         ::grpc::ByteBuffer * /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithStreamedUnaryMethod_placeCardSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_placeCardSlave() {
            ::grpc::Service::MarkMethodStreamed(
                0,
                new ::grpc::internal::StreamedUnaryHandler<::enginePackage::placeCardArgs,
                                                           ::enginePackage::ServerResponse>(
                    [this](::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::placeCardArgs, ::enginePackage::ServerResponse>
                               *streamer) { return this->StreamedplaceCardSlave(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_placeCardSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status placeCardSlave(::grpc::ServerContext * /*context*/,
                                      const ::enginePackage::placeCardArgs * /*request*/,
                                      ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedplaceCardSlave(
            ::grpc::ServerContext *context,
            ::grpc::ServerUnaryStreamer<::enginePackage::placeCardArgs, ::enginePackage::ServerResponse>
                *server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_playActionSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_playActionSlave() {
            ::grpc::Service::MarkMethodStreamed(
                1,
                new ::grpc::internal::StreamedUnaryHandler<::enginePackage::playActionArgs,
                                                           ::enginePackage::ServerResponse>(
                    [this](::grpc::ServerContext *context,
                           ::grpc::ServerUnaryStreamer<::enginePackage::playActionArgs, ::enginePackage::ServerResponse>
                               *streamer) { return this->StreamedplayActionSlave(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_playActionSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status playActionSlave(::grpc::ServerContext * /*context*/,
                                       const ::enginePackage::playActionArgs * /*request*/,
                                       ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedplayActionSlave(
            ::grpc::ServerContext *context,
            ::grpc::ServerUnaryStreamer<::enginePackage::playActionArgs, ::enginePackage::ServerResponse>
                *server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_endTurnSlave : public BaseClass {
      private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

      public:
        WithStreamedUnaryMethod_endTurnSlave() {
            ::grpc::Service::MarkMethodStreamed(
                2, new ::grpc::internal::StreamedUnaryHandler<::enginePackage::endTurnArgs,
                                                              ::enginePackage::ServerResponse>(
                       [this](::grpc::ServerContext *context,
                              ::grpc::ServerUnaryStreamer<::enginePackage::endTurnArgs, ::enginePackage::ServerResponse>
                                  *streamer) { return this->StreamedendTurnSlave(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_endTurnSlave() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status endTurnSlave(::grpc::ServerContext * /*context*/,
                                    const ::enginePackage::endTurnArgs * /*request*/,
                                    ::enginePackage::ServerResponse * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedendTurnSlave(::grpc::ServerContext *context,
                             ::grpc::ServerUnaryStreamer<::enginePackage::endTurnArgs, ::enginePackage::ServerResponse>
                                 *server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_placeCardSlave<
        WithStreamedUnaryMethod_playActionSlave<WithStreamedUnaryMethod_endTurnSlave<Service>>>
        StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_placeCardSlave<
        WithStreamedUnaryMethod_playActionSlave<WithStreamedUnaryMethod_endTurnSlave<Service>>>
        StreamedService;
};

} // namespace enginePackage

#endif // GRPC_engine_2eproto__INCLUDED
